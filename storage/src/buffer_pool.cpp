#pragma once

#include <vector>
#include <string>
#include <cstdint>
#include <memory>
#include <mutex>
#include <shared_mutex>
#include <optional>
#include <atomic>
#include "third_party/ConcurrentHashMap.h"
#include "storage/disk.hpp"
#include <variant>


struct PageId {
    std::string file_name;
    uint64_t page_id;
    
    bool operator==(const PageId& other) const {
        return file_name == other.file_name && page_id == other.page_id;
    }
    
    bool operator<(const PageId& other) const {
        if (file_name != other.file_name) {
            return file_name < other.file_name;
        }
        return page_id < other.page_id;
    }
};


struct PageIdHash {
    /**
     * Computes a hash value for a PageId object.
     *
     * The hash is generated by combining the hash of the file name
     * and the hash of the page ID, ensuring that PageId can be used
     * as a key in hash-based containers such as std::unordered_map
     * and std::unordered_set. The combination uses a simple XOR and
     * bit-shift operation to reduce collisions while keeping the
     * implementation lightweight.
     */
    std::size_t operator()(const PageId& pid) const {
        std::size_t h1 = std::hash<std::string>{}(pid.file_name);
        std::size_t h2 = std::hash<uint64_t>{}(pid.page_id);
        return h1 ^ (h2 << 1);
    }
};


struct Frame {
    PageId page_id;
    std::vector<uint8_t> data;
    std::shared_mutex page_mutex;
    std::atomic<bool> is_dirty{false};
    std::atomic<int>  pin_count{0};
    
    Frame() = default;
    Frame(const Frame&) = delete;
    Frame& operator=(const Frame&) = delete;
};


class BufferPoolManager;

template<typename LockType>
class PageHandle {
private:
    std::vector<uint8_t>* data_;
    LockType lock_;
    PageId page_id_;
    BufferPoolManager* buffer_manager_;
    bool is_dirty_;

public:
    PageHandle(std::vector<uint8_t>* data, LockType lock, const PageId& page_id, 
               BufferPoolManager* buffer_manager)
        : data_(data), lock_(std::move(lock)), page_id_(page_id), 
          buffer_manager_(buffer_manager), is_dirty_(false) {}
    
    // Move constructor
    PageHandle(PageHandle&& other) noexcept
        : data_(other.data_), lock_(std::move(other.lock_)), page_id_(other.page_id_),
          buffer_manager_(other.buffer_manager_), is_dirty_(other.is_dirty_) {
        other.data_ = nullptr;
        other.buffer_manager_ = nullptr;
    }
    
    // Move assignment
    PageHandle& operator=(PageHandle&& other) noexcept {
        if (this != &other) {
            cleanup();
            data_ = other.data_;
            lock_ = std::move(other.lock_);
            page_id_ = other.page_id_;
            buffer_manager_ = other.buffer_manager_;
            is_dirty_ = other.is_dirty_;
            other.data_ = nullptr;
            other.buffer_manager_ = nullptr;
        }
        return *this;
    }

    PageHandle(const PageHandle&) = delete;
    PageHandle& operator=(const PageHandle&) = delete;
    
    ~PageHandle() {
        cleanup();
    }
    

    std::vector<uint8_t>& data() { return *data_; }
    const std::vector<uint8_t>& data() const { return *data_; }
    
    std::vector<uint8_t>* operator->() { return data_; }
    const std::vector<uint8_t>* operator->() const { return data_; }
    
    std::vector<uint8_t>& operator*() { return *data_; }
    const std::vector<uint8_t>& operator*() const { return *data_; }
    
    void mark_dirty() { is_dirty_ = true; }
    bool is_valid() const { return data_ != nullptr && buffer_manager_ != nullptr; }

private:
    void cleanup();
};


using ReadPageHandle = PageHandle<std::shared_lock<std::shared_mutex>>;
using WritePageHandle = PageHandle<std::unique_lock<std::shared_mutex>>;


class BufferPoolManager {

private:

    static constexpr size_t DEFAULT_BUFFER_POOL_SIZE = 1000;
    std::vector<std::unique_ptr<Frame>> frames_;
    size_t pool_size_;
    ConcurrentHashMap<PageId, size_t, PageIdHash> page_table_;
    std::vector<size_t> free_frames_;
    mutable std::mutex free_frames_mutex_;
    std::shared_mutex buffer_pool_mutex_;
    
    BufferPoolManager(size_t pool_size = DEFAULT_BUFFER_POOL_SIZE) 
        : pool_size_(pool_size) {
        frames_.reserve(pool_size_);
        free_frames_.reserve(pool_size_);
        for (size_t i = 0; i < pool_size_; ++i) {
            frames_.emplace_back(std::make_unique<Frame>());
            free_frames_.push_back(i);
        }
    }

    std::optional<size_t> get_free_frame() {
        std::lock_guard<std::mutex> lock(free_frames_mutex_);
        if (free_frames_.empty()) {
            return std::nullopt;
        }
        size_t frame_idx = free_frames_.back();
        free_frames_.pop_back();
        return frame_idx;
    }
    

    void return_free_frame(size_t frame_idx) {
        std::lock_guard<std::mutex> lock(free_frames_mutex_);
        free_frames_.push_back(frame_idx);
    }
    

    void load_page_to_frame(const PageId& page_id, size_t frame_idx) {
        auto& frame = frames_[frame_idx];
        frame->data = read_page(page_id.file_name, page_id.page_id);
        frame->page_id = page_id;
        frame->is_dirty.store(false);
        frame->pin_count.store(1);
    }
    
    void flush_page(size_t frame_idx) {
        auto& frame = frames_[frame_idx];
        if (frame->is_dirty.load()) {
            write_page(frame->page_id.file_name, frame->page_id.page_id, frame->data);
            frame->is_dirty.store(false);
        }
    }

    using PageHandleVariant = std::variant<ReadPageHandle, WritePageHandle>;

    PageHandleVariant fetch_page_internal(
        const std::string& file_name, uint64_t page_id, bool is_write) {
        
        PageId pid{file_name, page_id};
        auto frame_idx_opt = page_table_.get(pid);
        
        if (frame_idx_opt) {
            /*
            * Page Already Exists in the Buffer Pool.
            */
            size_t frame_idx = *frame_idx_opt;
            auto& frame = frames_[frame_idx];
            frame->pin_count.fetch_add(1);
            if (is_write) {
                frame->page_mutex.lock();
                return PageHandle<std::unique_lock<std::shared_mutex>>(
                    &frame->data, 
                    std::unique_lock<std::shared_mutex>(frame->page_mutex, std::adopt_lock),
                    pid, this);
            } else {
                frame->page_mutex.lock_shared();
                return PageHandle<std::shared_lock<std::shared_mutex>>(
                    &frame->data,
                    std::shared_lock<std::shared_mutex>(frame->page_mutex, std::adopt_lock),
                    pid, this);
            }
        }
        
        std::unique_lock<std::shared_mutex> pool_lock(buffer_pool_mutex_);
        frame_idx_opt = page_table_.get(pid);
        if (frame_idx_opt) {
            /*
            * This is the case where multiple threads initially tried fetching the page but couldn't find them in the buffer pool initially.
            * Once buffer_pool_mutex_ is acquired by one of the threads trying to load the page from the disk into the page,
            * we check if the page is already loaded by one of the other threads to avoid loading the same page twice.
            */
            pool_lock.unlock();
            size_t frame_idx = *frame_idx_opt;
            auto& frame = frames_[frame_idx];
            frame->pin_count.fetch_add(1);
            if (is_write) {
                frame->page_mutex.lock();
                return PageHandle<std::unique_lock<std::shared_mutex>>(
                    &frame->data, 
                    std::unique_lock<std::shared_mutex>(frame->page_mutex, std::adopt_lock),
                    pid, this);
            } else {
                frame->page_mutex.lock_shared();
                return PageHandle<std::shared_lock<std::shared_mutex>>(
                    &frame->data,
                    std::shared_lock<std::shared_mutex>(frame->page_mutex, std::adopt_lock),
                    pid, this);
            }
            
        
        }
        

        /*
        * Thread has to load the page into the buffer pool.
        */
        auto free_frame_idx = get_free_frame();
        if (!free_frame_idx) {
            throw std::runtime_error("No free frames available in buffer pool");
        }
        
        size_t frame_idx = *free_frame_idx;
        load_page_to_frame(pid, frame_idx);
        page_table_.insert(pid, frame_idx);
        auto& frame = frames_[frame_idx];
        if (is_write) {
            frame->page_mutex.lock();
            return PageHandle<std::unique_lock<std::shared_mutex>>(
                    &frame->data, 
                    std::unique_lock<std::shared_mutex>(frame->page_mutex, std::adopt_lock),
                    pid, this);
        } else {
            frame->page_mutex.lock_shared();
            return PageHandle<std::shared_lock<std::shared_mutex>>(
                    &frame->data,
                    std::shared_lock<std::shared_mutex>(frame->page_mutex, std::adopt_lock),
                    pid, this);
        }
    }
    

    size_t get_frame_index(const PageId& pid) const {
        auto frame_idx_opt = page_table_.get(pid);
        if (!frame_idx_opt) {
            throw std::runtime_error("Page not found in buffer pool");
        }
        return *frame_idx_opt;
    }

public:

    static BufferPoolManager& get_instance() {
        static BufferPoolManager instance;
        return instance;
    }
    
    BufferPoolManager(const BufferPoolManager&) = delete;
    BufferPoolManager& operator=(const BufferPoolManager&) = delete;
    
    
    ReadPageHandle fetch_page_read(const std::string& file_name, uint64_t page_id) {
        auto variant = fetch_page_internal(file_name, page_id, false);
        return std::get<ReadPageHandle>(std::move(variant));
    }
    
    WritePageHandle fetch_page_write(const std::string& file_name, uint64_t page_id) {
        auto variant = fetch_page_internal(file_name, page_id, true);
        return std::get<WritePageHandle>(std::move(variant));
    }
    
    
    bool unpin_page(const std::string& file_name, uint64_t page_id, bool is_dirty = false) {
        PageId pid{file_name, page_id};
        
        auto frame_idx_opt = page_table_.get(pid);
        if (!frame_idx_opt) {
            return false;
        }
        
        size_t frame_idx = *frame_idx_opt;
        auto& frame = frames_[frame_idx];
        
        if (is_dirty) {
            frame->is_dirty.store(true);
        }
        
        int old_pin_count = frame->pin_count.fetch_sub(1);
        return old_pin_count > 0;
    }
    
    bool flush_page(const std::string& file_name, uint64_t page_id) {
        PageId pid{file_name, page_id};
        
        auto frame_idx_opt = page_table_.get(pid);
        if (!frame_idx_opt) {
            return false;
        }
        
        size_t frame_idx = *frame_idx_opt;
        auto& frame = frames_[frame_idx];
        
        std::unique_lock<std::shared_mutex> lock(frame->page_mutex);
        flush_page(frame_idx);
        return true;
    }
    

    void flush_all_pages() {
        std::shared_lock<std::shared_mutex> pool_lock(buffer_pool_mutex_);
        
        for (size_t i = 0; i < pool_size_; ++i) {
            auto& frame = frames_[i];
            if (frame->pin_count.load() > 0) {
                std::unique_lock<std::shared_mutex> page_lock(frame->page_mutex);
                flush_page(i);
            }
        }
    }
    

    struct PoolStats {
        size_t total_frames;
        size_t free_frames;
        size_t pinned_frames;
        size_t dirty_frames;
    };
    
    PoolStats get_stats() const {
        PoolStats stats;
        stats.total_frames = pool_size_;
        
        {
            std::lock_guard<std::mutex> lock(free_frames_mutex_);
            stats.free_frames = free_frames_.size();
        }
        
        stats.pinned_frames = 0;
        stats.dirty_frames = 0;
        
        for (const auto& frame : frames_) {
            if (frame->pin_count.load() > 0) {
                stats.pinned_frames++;
            }
            if (frame->is_dirty.load()) {
                stats.dirty_frames++;
            }
        }
        
        return stats;
    }
};


inline ReadPageHandle fetch_page_read(const std::string& file_name, uint64_t page_id) {
    return BufferPoolManager::get_instance().fetch_page_read(file_name, page_id);
}

inline WritePageHandle fetch_page_write(const std::string& file_name, uint64_t page_id) {
    return BufferPoolManager::get_instance().fetch_page_write(file_name, page_id);
}

inline bool flush_page(const std::string& file_name, uint64_t page_id) {
    return BufferPoolManager::get_instance().flush_page(file_name, page_id);
}

// Example usage:
/*
int main() {
    // Fetch a page for reading - automatically unpinned when handle goes out of scope
    {
        auto page_handle = fetch_page_read("test.db", 1);
        // Use page_handle.data() or page_handle->... or *page_handle for reading
        auto& page_data = page_handle.data();
        // Lock is automatically released and page unpinned when page_handle goes out of scope
    }
    
    // Fetch a page for writing - automatically unpinned and marked dirty if needed
    {
        auto page_handle = fetch_page_write("test.db", 2);
        // Modify the page data
        page_handle->push_back(42);  // Example modification
        page_handle.mark_dirty();    // Mark as dirty for proper persistence
        // Lock is automatically released and page unpinned when page_handle goes out of scope
    }
    
    // Manual flush if needed
    flush_page("test.db", 2);
    
    // Can also move handles around
    auto get_page = []() -> WritePageHandle {
        return fetch_page_write("test.db", 3);
    };
    
    auto page = get_page();  // Page is still properly managed
    page->resize(4096);      // Modify the page
    page.mark_dirty();
    // Automatically cleaned up when page goes out of scope
    
    return 0;
}
*/
